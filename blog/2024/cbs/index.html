<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The Cantor-Schröder-Bernstein theorem | Peterson Yuhala </title> <meta name="author" content="Peterson Yuhala"> <meta name="description" content="Intuitive proof of the Cantor-Schröder-Bernstein theorem"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/p-logo.png?3663dcf521c885064fd249add8b2c72b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuhala.github.io/blog/2024/cbs/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Peterson </span> Yuhala </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/awards/">Awards </a> </li> <li class="nav-item "> <a class="nav-link" href="/personal/">Personal </a> </li> <li class="nav-item "> <a class="nav-link" href="/service/">Service </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">The Cantor-Schröder-Bernstein theorem</h1> <p class="post-meta"> July 08, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a>     ·   <a href="/blog/category/math"> <i class="fa-solid fa-tag fa-sm"></i> math</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="definition">Definition</h3> <p>If \(A\) and \(B\) are sets with \(|A| \leq |B|\) and \(|B| \leq |A|\), then \(|A|=|B|\). In other words, if there are injections \(f:A \longrightarrow B\) and \(g:B \longrightarrow A\), then there is a bijection \(h:A \longrightarrow B\).</p> <h3 id="proof">Proof</h3> <p>This theorem seems to be straightforward and one might expect that is has an easy proof. However, no known proof of this theorem is ”easy” to explain, even without using advanced mathematics. To put this into perspective, Ernst Schröder (whose name appears in the theorem title) published a flawed proof in 1898.</p> <p>To provide a more interesting perspective on the proof of the theorem, we will make use of <a href="https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel#:~:text=4%20References-,The%20paradox,each%20expecting%20their%20own%20room." rel="external nofollow noopener" target="_blank">Hilbert’s Grand Hotel paradox</a>, a famous thought experiment formulated by German Mathematician David Hilbert. It shows the counter-intuitive properties of infinite sets. Hilbert used it as an example to show how infinity does not act in the same was as regular numbers do.</p> <p><strong>Hilbert’s paradox</strong>: Hilbert invented the notion of the Grand Hotel, which has a <code class="language-plaintext highlighter-rouge">countably infinite</code> number of rooms, each occupied by a guest. However, when a new guest arrives, it is always possible to find a room for this guest without evicting a current guest from the hotel. The paradox here is that even though the hotel was initially <code class="language-plaintext highlighter-rouge">fully occupied</code>, it can always make room for additional guests without evicting current guests.</p> <p>Because the rooms of the Grand Hotel are countable, we can list them as room 1, room 2, room 3, and so on. When a new guest arrives, we move the guest in room 1 to room 2, the guest in room 2 to room 3, and in general, the guest in room n to room n + 1, for all positive integers n. This frees up room 1, which we assign to the new guest, and all the current guests still have rooms.</p> <p>Similarly, if a countably infinite number of new guests arrive, we move the guest in room \(n\) to room \(2n\). This frees up all the odd number rooms \((2n − 1)\), which can then be occupied by the infinite number of guests.</p> <p>When dealing with a finite number of rooms in a hotel, the notion that all rooms are occupied is equivalent to the notion that no new guests can be accommodated. However, Hilbert’s paradox of the Grand Hotel can be explained by noting that this equivalence no longer holds when there are infinitely many rooms.</p> <p>Now, going back to the original Cantor-Schröder-Bernstein (CSB) theorem, we can draw a connection between Hilbert’s infinite hotel and the theorem by considering set A as hotel guests, and set B as rooms in the hotel. Our objective is to map each guest to a distinct room (ensuring that no two guests share a room) and ensure that all the rooms are occupied at the end of the process. In other words, we want to construct a bijection between sets \(A\) and \(B\). Function \(f\) associates a guest to a room, while function \(g\) tells us which guest occupies a specific room.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/hilbert-hotel.png" alt="" title=""> </div> </div> <p>We shall focus on set \(A_0 = A − g(B)\), the new guests who don’t have rooms yet. That is, the elements of \(A\) that are not in the image of \(B\) under \(g\). We can find rooms for them using \(f\) with the mapping: \(f(A_0)\). However, there could already be guests occupying the rooms \(f(A_0)\), so we will need to move these guests \(A_1\) to new rooms. But first we need to know the guests to be moved by using function \(g\) which gives us: \(A_1 = g(f(A_0))\). Similarly, we can use f to find rooms for them by doing \(f(A_1) = f(g(f(A_0)))\), and we will repeat this infinitely many times. We can formalize this to obtain the following definitions:</p> <p>\(A_0 = A - g(B)\)<br> \(A_{n+1} = gf(A_n)\)<br> \(A_\infty = \bigcup\limits_{n=0}^{\infty} A_n\)</p> <p>We can then define \(h:A \longrightarrow B\) as follows: \(\begin{cases} f(x) &amp; x\in A_\infty\\ g^{-1}(x) &amp; x\in A-A_\infty \end{cases}\)</p> <p>What this means in terms of the hotel is, if guest \(x\) is a new guest or a guest that is being displaced, we will find a room for guest \(x\) using \(f(x)\). Otherwise, if guest \(x\) is not being displaced, we will simply leave the guest in the room they currently occupy, i.e., \(g^{-1}(x)\). We just need to show that h is indeed bijective.</p> <h3 id="showing-h-is-injective">Showing h is injective</h3> <p>For \(x, y \in A\), suppose \(h(x) = h(y)\). We have 4 possibilities:</p> <ol> <li>\(x, y \in A_\infty\) : This means \(f(x) = f(y) \implies x = y\), since \(f\) is injective.</li> <li>\(x, y \in A_\infty\): This means \(g^{-1}(x) = g^{-1}(y) \implies x = y\), since \(g\) is injective.</li> <li>\(x \in A_\infty\) and \(y \in A - A_\infty\): \(x \in A_\infty\) means \(x \in A_n\) for some \(n\). So \(h(x) = h(y) \implies f(x) = g^{-1}(y)\), so \(y = g(f(x)) \in g(f(A)) = A_{n+1}\); this is a contradiction since y is suppposed to be in \(A - A_\infty\).</li> <li>\(x \in A - A_\infty\) and \(y \in A - A_\infty\): this is symmetric to case 2, and so is covered without loss of generality.</li> </ol> <h3 id="showing-h-is-surjective">Showing h is surjective</h3> <p>TODO</p> <h3 id="references">References</h3> <ul> <li><a href="https://billcookmath.com/courses/math2510-spring2010/Schroder-Bernstein.pdf" rel="external nofollow noopener" target="_blank">Bill Cook Math</a></li> <li><a href="https://www.youtube.com/watch?v=IkoKttTDuxE&amp;feature=youtu.be" rel="external nofollow noopener" target="_blank">Youtube: Cantor-Schröder-Bernstein theorem</a></li> <li><a href="https://math24.net/cantor-schroder-bernstein-theorem.html" rel="external nofollow noopener" target="_blank">Math24 Set Theory</a></li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Peterson Yuhala. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>