<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Programming with Makefiles | Peterson Yuhala </title> <meta name="author" content="Peterson Yuhala"> <meta name="description" content="automate your builds with make."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/p-logo.png?3663dcf521c885064fd249add8b2c72b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yuhala.github.io/blog/2021/makefiles/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Peterson </span> Yuhala </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/awards/">Awards </a> </li> <li class="nav-item "> <a class="nav-link" href="/personal/">Personal </a> </li> <li class="nav-item "> <a class="nav-link" href="/service/">Service </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Programming with Makefiles</h1> <p class="post-meta"> August 20, 2021 </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> C programmers never die. They are just cast into void.<br> --Alan Perlis </blockquote> <p>Hi all! Today we will be looking at <code class="language-plaintext highlighter-rouge">Makefiles</code>. First we will understand why we need them, after which we will dive into building a makefile for a simple C++ program. This tutorial is by no means exhaustive as to the capabilities of makefiles, but is intended as a helpful starting point for beginner programmers. This tutorial is adapted for a Linux environment.</p> <p>Makefiles are used to automate the build process for large projects. They are very common for C/C++ projects but can be used for other purposes once understood. To better appreciate the need for makefiles, let’s consider the following C++ program which creates an object that prints a message to the terminal. Our program consists of a header file <code class="language-plaintext highlighter-rouge">message.hpp</code> which defines a <code class="language-plaintext highlighter-rouge">class Message</code>, a C++ source file <code class="language-plaintext highlighter-rouge">message.cpp</code> which defines the methods of <code class="language-plaintext highlighter-rouge">class Message</code>, and a second C++ file which defines the <code class="language-plaintext highlighter-rouge">main</code> entrypoint of the program. The contents of the files are as follows:</p> <hr> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <tt>message.hpp</tt> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> <td class="code"><pre><span class="cp">#ifndef MESSAGE_HPP
#define MESSAGE_HPP
</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">hello</span><span class="p">();</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* MESSAGE_HPP */</span>
</pre></td> </tr></tbody></table></code></pre></figure> </div> <div class="col-sm mt-3 mt-md-0"> <tt>message.cpp</tt> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> <td class="code"><pre><span class="cp">#include</span> <span class="cpf">"message.hpp"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">hello</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello Peterson!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> </div> <div class="col-sm mt-3 mt-md-0"> <tt>main.cpp</tt> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> <td class="code"><pre><span class="cp">#include</span> <span class="cpf">"message.hpp"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Message</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">m</span><span class="p">.</span><span class="n">hello</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> </div> </div> <hr> <p>The files are placed following the directory structure below:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>app
|───src
|   |───headers
|   |   | message.hpp
|   | message.cpp
|   | main.cpp
|       
</code></pre></div></div> <p>To compile the program files into an executable binary <code class="language-plaintext highlighter-rouge">app</code>, we can run the following command from within the <code class="language-plaintext highlighter-rouge">app</code> directory: <code class="language-plaintext highlighter-rouge">g++ src/main.cpp src/message.cpp -Isrc/headers -o app -lstdc++</code>. Here the <code class="language-plaintext highlighter-rouge">g++</code> (GNU C++) compiler compiles the <code class="language-plaintext highlighter-rouge">.cpp</code> files into object files <code class="language-plaintext highlighter-rouge">.o</code> which are then bundled up by the linker to create the final executable binary <code class="language-plaintext highlighter-rouge">app</code>.</p> <p>The figure below summarises this process:</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <img class="img-fluid rounded z-depth-1" src="/assets/img/compilation.jpg" alt="" title=""> </div> </div> <p>We can then run our executable file with <code class="language-plaintext highlighter-rouge">./app</code>.</p> <p>Now this is nice and simple when we have a small project with just 2 or 3 source files to compile. Imagine a scenario where we had hundreds or thousands of source files. Using the above command becomes extremely tedious. Moreover, doing the above will recompile each file every time, regardless of whether it was modified or not. This is very inefficient, and here is where makefiles come into the picture.</p> <hr> <h3 id="structure-of-a-makefile">Structure of a makefile</h3> <p>In its simplest form, the content of a makefile comprises chunks of instructions known as <code class="language-plaintext highlighter-rouge">rules</code> with the following structure:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>target: dependencies
    recipe
</code></pre></div></div> <p>A <code class="language-plaintext highlighter-rouge">target</code> is the output generated by the program, e.g <tt>executable files</tt> or <tt>object files</tt>. The <code class="language-plaintext highlighter-rouge">dependencies</code> or <code class="language-plaintext highlighter-rouge">prerequisites</code> are files used to create the target, e.g <tt>.c</tt>, <tt>.cpp</tt>, or <tt>.o</tt> files. And lastly, the <code class="language-plaintext highlighter-rouge">recipe</code> is a command or action that the make tool carries out to produce a target using the given dependencies. Note: we have a tab after <code class="language-plaintext highlighter-rouge">:</code> and just before <code class="language-plaintext highlighter-rouge">recipe</code>. This is an important detail to note because <code class="language-plaintext highlighter-rouge">trailing whitespaces</code> in makefiles are problematic and often tedious to fix.</p> <p>Going back to our example program, we have 3 outputs (our make <code class="language-plaintext highlighter-rouge">targets</code>): <code class="language-plaintext highlighter-rouge">message.o</code> (target 1) after compilation of <code class="language-plaintext highlighter-rouge">message.cpp</code> (a dependency), <code class="language-plaintext highlighter-rouge">main.o</code> (target 2) after compilation of <code class="language-plaintext highlighter-rouge">main.cpp</code>, and lastly the final binary, <code class="language-plaintext highlighter-rouge">app</code> (target 3), after linking <code class="language-plaintext highlighter-rouge">message.o</code>, <code class="language-plaintext highlighter-rouge">main.o</code> (its dependencies), and the C++ standard library <code class="language-plaintext highlighter-rouge">stdc++</code>. Targets <code class="language-plaintext highlighter-rouge">message.o</code> and <code class="language-plaintext highlighter-rouge">main.o</code> will have <code class="language-plaintext highlighter-rouge">message.hpp</code> as a dependency since they should be recompiled/rebuilt if that header file is changed.</p> <p>Using this information, we can create a very simple make file called <code class="language-plaintext highlighter-rouge">Makefile</code> in the <code class="language-plaintext highlighter-rouge">app directory</code>, and input 3 rules which will permit us to build the final program. The rules are as follows:</p> <hr> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>message.o: src/message.cpp src/headers/message.hpp
	g++ -Isrc/headers -c src/message.cpp -o message.o

main.o: src/main.cpp src/headers/message.hpp 
	g++ -Isrc/headers -c src/main.cpp -o main.o

app: message.o main.o
	g++ -Isrc/headers message.o main.o -o app -lstdc++
</code></pre></div></div> <hr> <p>We can then build our program by running <code class="language-plaintext highlighter-rouge">make app</code> which will produce 3 files: <code class="language-plaintext highlighter-rouge">message.o</code>, <code class="language-plaintext highlighter-rouge">main.o</code>, and <code class="language-plaintext highlighter-rouge">app</code>. You notice that we instructed make to build the target <code class="language-plaintext highlighter-rouge">app</code> but make builds the first two targets because they are dependencies of <code class="language-plaintext highlighter-rouge">app</code>, and the make file contains rules to build them too. If the rule to build <code class="language-plaintext highlighter-rouge">message.o</code> or <code class="language-plaintext highlighter-rouge">main.o</code> was absent, make will inform you it cannot find the rule to build that dependency and exit sadly.</p> <h3 id="extended-makefile">Extended makefile</h3> <p>The makefile above is enough for us to understand the basic principles of make. However you will hardly see such simple makefiles in practice. You can have a look at a makefile from the linux kernel <a href="https://github.com/torvalds/linux/blob/master/Makefile" rel="external nofollow noopener" target="_blank">here</a> to have an idea. Frightful <img class="emoji" title=":fearful:" alt=":fearful:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png" height="20" width="20"> right ? So in this section, we will extend our makefile so it looks much more professional and geeky<img class="emoji" title=":sunglasses:" alt=":sunglasses:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png" height="20" width="20">.</p> <p>If we observe our rules above, we notice some repetition such as <code class="language-plaintext highlighter-rouge">-Isrc/headers</code>, <code class="language-plaintext highlighter-rouge">src/headers/message.hpp</code> or even <code class="language-plaintext highlighter-rouge">g++</code>. These could be much longer in practice, which will lead to a very clumsy make file. This brings us to the idea of <code class="language-plaintext highlighter-rouge">make variables</code>. A variable in make is simply a name defined in the makefile to represent a string of text. It is good practice to name variables in all CAPITALS. If we define a variable <code class="language-plaintext highlighter-rouge">PATH := /path/to/file</code> (you can use <code class="language-plaintext highlighter-rouge">=</code> too), we can access its value with <code class="language-plaintext highlighter-rouge">$(PATH)</code>. You must define a variable before you try to reference its value.</p> <p>Using this knowledge, we shall define a few variables at the top of our previous make file as follows:</p> <hr> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CXX := g++

SRC := src
INCLUDE_PATHS := -Isrc/headers
COMPILE_FLAGS := $(INCLUDE_PATHS)
LD_FLAGS := -lstdc++

HEADERS := $(wildcard src/headers/*.hpp)

OBJ_NAMES := message.o main.o 
APP_OBJS := $(addprefix $(SRC)/,$(OBJ_NAMES))

APP_NAME := app
</code></pre></div></div> <hr> <p>Most of the variable definitions above are self-explanatory except for a few. For the <code class="language-plaintext highlighter-rouge">HEADERS</code> variable, the <code class="language-plaintext highlighter-rouge">wildcard</code> syntax simply means <code class="language-plaintext highlighter-rouge">all the .hpp files in the src/headers folder</code>. The <code class="language-plaintext highlighter-rouge">OBJ_NAMES</code> variable is a list with the object file names. As for the <code class="language-plaintext highlighter-rouge">APP_OBJS</code> variable, the <code class="language-plaintext highlighter-rouge">addprefix</code> command appends <code class="language-plaintext highlighter-rouge">src/</code> to each of the object file names. So <code class="language-plaintext highlighter-rouge">APP_OBJS</code> expands to: <code class="language-plaintext highlighter-rouge">APP_OBJS := src/message.o src/main.o</code>.</p> <p>Next thing we notice is the set of rules. We observe that the rules for targets <code class="language-plaintext highlighter-rouge">message.o</code> and <code class="language-plaintext highlighter-rouge">main.o</code> are quite similar. Using make <a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html#Pattern-Intro" rel="external nofollow noopener" target="_blank">patterns</a>, we can create a generic rule for both targets. We can also add an additional action in our rules to print messages. Using our newly defined variables, our new rule (for both targets: <code class="language-plaintext highlighter-rouge">message.o</code> and <code class="language-plaintext highlighter-rouge">main.o</code>) would look like this follows:</p> <hr> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$(SRC)/%.o: $(SRC)/%.cpp $(HEADERS)
	@$(CXX) $(COMPILE_FLAGS) -c $&lt; -o $@
	@echo "CXX &lt;= $&lt;" 
</code></pre></div></div> <hr> <p>It looks a bit frightful but we will break it down. <code class="language-plaintext highlighter-rouge">$(SRC)/%.o</code> is a <code class="language-plaintext highlighter-rouge">target-patten</code> which will match all object file names (targets) in the <code class="language-plaintext highlighter-rouge">src</code> directory. Similarly, <code class="language-plaintext highlighter-rouge">$(SRC)/%.cpp</code> is a <code class="language-plaintext highlighter-rouge">prereq-patten</code> which will match all the <code class="language-plaintext highlighter-rouge">.cpp</code> files in the src directory. The <code class="language-plaintext highlighter-rouge">@</code> symbol before an action prevents the full command from being printed to the terminal. <code class="language-plaintext highlighter-rouge">$&lt;</code> is an <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables" rel="external nofollow noopener" target="_blank">automatic variable</a> which represents the <code class="language-plaintext highlighter-rouge">first prerequisite</code> in the rule (i.e <code class="language-plaintext highlighter-rouge">$(SRC)/%.cpp</code>) in our case, while <code class="language-plaintext highlighter-rouge">$@</code> is an automatic variable which represents the <code class="language-plaintext highlighter-rouge">target</code> of the rule (i.e <code class="language-plaintext highlighter-rouge">$(SRC)/%.o</code>). The rule with <code class="language-plaintext highlighter-rouge">echo</code> simply prints the prerequisite being compiled by g++.</p> <p>Similarly, we can create a more concise rule for the <code class="language-plaintext highlighter-rouge">app</code> target as follows:</p> <hr> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$(APP_NAME): $(APP_OBJS)
	@$(CXX) $(COMPILE_FLAGS) $^ -o $@ $(LD_FLAGS)
</code></pre></div></div> <hr> <p>This is similar to the generic rule above except for a new automatic variable <code class="language-plaintext highlighter-rouge">$^</code>. The latter represents <code class="language-plaintext highlighter-rouge">all the prerequisites</code> in the rule (i.e <code class="language-plaintext highlighter-rouge">$(APP_OBJS)</code> in our case).</p> <p>Our makefile looks really geeky and professional at the moment but we will add one final ingredient to the mix.</p> <h3 id="phony-targets">PHONY targets</h3> <p>Sometimes we may want a rule whose target is not necessarily a file. An example could be a rule to simply delete or <code class="language-plaintext highlighter-rouge">clean</code> previously compiled targets. We call the corresponding targets <code class="language-plaintext highlighter-rouge">PHONY targets</code>. The latter have no dependencies. We will define a PHONY target called <code class="language-plaintext highlighter-rouge">clean</code> to delete all previously compiled files as follows:</p> <hr> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.PHONY: clean

clean:
	@rm $(APP_NAME) $(APP_OBJS) 
</code></pre></div></div> <hr> <p>Now our makefile is complete !! You can bundle up the variable definitions, the two generic rules, and the last PHONY target rule into your makefile and rebuild your application again with the <code class="language-plaintext highlighter-rouge">make app</code> command in your terminal. To delete the previously compiled files, we simply type the command <code class="language-plaintext highlighter-rouge">make clean</code> in our terminal.</p> <p>For more in-depth information on make, you can visit the <a href="https://www.gnu.org/software/make/manual/html_node/" rel="external nofollow noopener" target="_blank">official site</a>.</p> <hr> <p>Thanks for keeping up until this point. I hope you learnt alot. Stay tuned for the next tips in my tech diaries.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/phdtools/">Productivity tools for every PhD student</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/cbs/">The Cantor-Schröder-Bernstein theorem</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2015/math/">a post with math</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/diagrams/">a post with diagrams</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/twitter/">a post with twitter</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Peterson Yuhala. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>